/**
 * sync-metrics.js
 * Parses _agents/_sessions/*.md files for Meeting Metrics blocks.
 * Computes per-agent $/hr, ms-in-use, and quest score across time windows.
 * Outputs src/content/metrics.json for the Team page.
 */

const fs = require('fs');
const path = require('path');

const SESSIONS_DIR = path.join(__dirname, '..', '..', '_agents', '_sessions');
const RESEARCH_DIR = path.join(__dirname, '..', '..', 'research');
const HANDOFFS_DIR = path.join(__dirname, '..', '..', '_agents', '_handoffs');
const ROADMAP_PATH = path.join(__dirname, '..', '..', '_agents', 'roadmap-2026.json');
const OUTPUT_PATH = path.join(__dirname, '..', 'src', 'content', 'metrics.json');

const WINDOWS = {
  '24h': 24 * 60 * 60 * 1000,
  '48h': 48 * 60 * 60 * 1000,
  '7d': 7 * 24 * 60 * 60 * 1000,
  '30d': 30 * 24 * 60 * 60 * 1000,
};

const AGENTS = ['grok', 'claude', 'gemini', 'abacus'];

/**
 * Parse a session markdown file for Meeting Metrics block.
 * Returns { date, totalCost, totalTokens, durationS, byAgent: { name: cost } }
 */
function parseSessionFile(filePath) {
  const content = fs.readFileSync(filePath, 'utf-8');
  const fileName = path.basename(filePath);

  // Extract date from filename (e.g., 2026-02-17-daily-briefing.md)
  const dateMatch = fileName.match(/^(\d{4}-\d{2}-\d{2})/);
  if (!dateMatch) return null;

  const sessionDate = new Date(dateMatch[1] + 'T12:00:00Z');

  // Find Meeting Metrics section
  const metricsMatch = content.match(/## Meeting Metrics[\s\S]*?(?=\n## |\n---|\n```|$)/);
  if (!metricsMatch) return null;

  const metricsBlock = metricsMatch[0];

  // Parse total cost
  const costMatch = metricsBlock.match(/\*\*Total Cost\*\*:\s*\$?([\d.]+)/);
  const totalCost = costMatch ? parseFloat(costMatch[1]) : 0;

  // Parse tokens
  const tokensMatch = metricsBlock.match(/\*\*Tokens\*\*:\s*([\d,]+)/);
  const totalTokens = tokensMatch ? parseInt(tokensMatch[1].replace(/,/g, '')) : 0;

  // Parse duration
  const durationMatch = metricsBlock.match(/\*\*Duration\*\*:\s*([\d.]+)s/);
  const durationS = durationMatch ? parseFloat(durationMatch[1]) : 0;

  // Parse by-agent costs
  const byAgent = {};
  const agentRegex = /- {2}(\w+):\s*\$?([\d.]+)/g;
  let match;
  while ((match = agentRegex.exec(metricsBlock)) !== null) {
    byAgent[match[1].toLowerCase()] = parseFloat(match[2]);
  }

  // Count action items per agent from the full content
  const actionItems = {};
  const actionMatch = content.match(/## Action Items[\s\S]*?(?=\n## |$)/);
  if (actionMatch) {
    for (const agent of AGENTS) {
      const agentActions = (actionMatch[0].match(new RegExp(agent, 'gi')) || []).length;
      if (agentActions > 0) actionItems[agent] = agentActions;
    }
  }

  // Count debate contributions (agent name mentions in debate sections)
  const debateContribs = {};
  for (const agent of AGENTS) {
    const headerPattern = new RegExp(`### ${agent}|\\[${agent}\\]`, 'gi');
    const contributions = (content.match(headerPattern) || []).length;
    if (contributions > 0) debateContribs[agent] = contributions;
  }

  return {
    date: sessionDate,
    totalCost,
    totalTokens,
    durationS,
    byAgent,
    actionItems,
    debateContribs,
    fileName,
  };
}

/**
 * Count research briefs per agent by scanning research directory.
 */
function countResearchBriefs() {
  const counts = {};
  if (!fs.existsSync(RESEARCH_DIR)) return counts;

  function scanDir(dir) {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      if (entry.isDirectory()) {
        scanDir(fullPath);
      } else if (entry.name.endsWith('.md') && entry.name !== 'README.md') {
        try {
          const content = fs.readFileSync(fullPath, 'utf-8');
          // Check for author attribution
          for (const agent of AGENTS) {
            if (content.toLowerCase().includes(`author: ${agent}`) ||
                content.toLowerCase().includes(`generated by: ${agent}`) ||
                content.toLowerCase().includes(`by ${agent}`)) {
              counts[agent] = (counts[agent] || 0) + 1;
            }
          }
          // Count Russell's contributions
          if (content.toLowerCase().includes('author: russell') ||
              content.toLowerCase().includes('generated by: russell')) {
            counts['russell'] = (counts['russell'] || 0) + 1;
          }
        } catch (e) { /* skip unreadable files */ }
      }
    }
  }

  scanDir(RESEARCH_DIR);
  return counts;
}

/**
 * Count completed handoffs per agent.
 */
function countCompletedHandoffs() {
  const counts = {};
  const archiveDir = path.join(HANDOFFS_DIR, 'archive');
  if (!fs.existsSync(archiveDir)) return counts;

  const files = fs.readdirSync(archiveDir);
  for (const file of files) {
    if (!file.endsWith('.md')) continue;
    try {
      const content = fs.readFileSync(path.join(archiveDir, file), 'utf-8');
      for (const agent of AGENTS) {
        if (content.toLowerCase().includes(`assigned to.*${agent}`) ||
            content.toLowerCase().includes(`assigned_to.*${agent}`) ||
            content.toLowerCase().includes(agent)) {
          counts[agent] = (counts[agent] || 0) + 1;
        }
      }
    } catch (e) { /* skip */ }
  }
  return counts;
}

/**
 * Load milestone completions from roadmap file.
 */
function loadMilestones() {
  const scores = {};
  if (!fs.existsSync(ROADMAP_PATH)) return scores;

  try {
    const roadmap = JSON.parse(fs.readFileSync(ROADMAP_PATH, 'utf-8'));
    const milestones = roadmap.milestones || [];

    for (const milestone of milestones) {
      if (milestone.status === 'completed') {
        const contributors = milestone.contributors || [];
        for (const contributor of contributors) {
          const name = contributor.toLowerCase();
          scores[name] = (scores[name] || 0) + (milestone.points || 10);
        }
      }
    }
  } catch (e) {
    console.warn('Could not load roadmap:', e.message);
  }
  return scores;
}

/**
 * Compute quest scores for all agents.
 */
function computeQuestScores(sessions, window, researchCounts, handoffCounts, milestoneScores) {
  const now = Date.now();
  const cutoff = now - window;
  const relevantSessions = sessions.filter(s => s.date.getTime() >= cutoff);

  const raw = {};

  for (const agent of [...AGENTS, 'russell']) {
    // Output: research briefs + handoffs completed
    const briefs = researchCounts[agent] || 0;
    const handoffs = handoffCounts[agent] || 0;
    const output = briefs * 5 + handoffs * 10;

    // Milestones: from roadmap
    const milestones = milestoneScores[agent] || 0;

    // Efficiency: inverse of $/token (lower cost = higher score)
    let totalCost = 0;
    let totalTokens = 0;
    for (const session of relevantSessions) {
      totalCost += session.byAgent[agent] || 0;
      if (session.byAgent[agent]) {
        // Estimate tokens from cost proportion
        const proportion = session.totalTokens > 0 ? (session.byAgent[agent] / Math.max(session.totalCost, 0.001)) : 0;
        totalTokens += Math.round(session.totalTokens * proportion);
      }
    }
    // Cost per 1K tokens (lower is better)
    const costPer1K = totalTokens > 0 ? (totalCost / totalTokens) * 1000 : 0;
    const efficiency = costPer1K > 0 ? Math.max(0, 100 - (costPer1K * 500)) : 0; // Normalize

    // Initiative: action items + debate contributions
    let actionItems = 0;
    let debateContribs = 0;
    for (const session of relevantSessions) {
      actionItems += session.actionItems[agent] || 0;
      debateContribs += session.debateContribs[agent] || 0;
    }
    const initiative = (actionItems * 15) + (debateContribs * 5);

    raw[agent] = { output, milestones, efficiency, initiative };
  }

  // Normalize each dimension relative to max
  const dimensions = ['output', 'milestones', 'efficiency', 'initiative'];
  const normalized = {};

  for (const agent of [...AGENTS, 'russell']) {
    normalized[agent] = {};
    for (const dim of dimensions) {
      const maxVal = Math.max(...Object.values(raw).map(r => r[dim]), 1);
      normalized[agent][dim] = Math.round((raw[agent][dim] / maxVal) * 100);
    }

    // Weighted score
    normalized[agent].total = Math.round(
      normalized[agent].output * 0.30 +
      normalized[agent].milestones * 0.25 +
      normalized[agent].efficiency * 0.25 +
      normalized[agent].initiative * 0.20
    );
  }

  return normalized;
}

// ===== MAIN =====

function main() {
  console.log('Syncing agent metrics...');

  // Parse all session files
  const sessions = [];
  if (fs.existsSync(SESSIONS_DIR)) {
    const files = fs.readdirSync(SESSIONS_DIR).filter(f => f.endsWith('.md'));
    for (const file of files) {
      const parsed = parseSessionFile(path.join(SESSIONS_DIR, file));
      if (parsed) sessions.push(parsed);
    }
  }
  console.log(`  Parsed ${sessions.length} sessions with metrics`);

  // Count research and handoffs
  const researchCounts = countResearchBriefs();
  const handoffCounts = countCompletedHandoffs();
  const milestoneScores = loadMilestones();

  console.log(`  Research briefs: ${JSON.stringify(researchCounts)}`);
  console.log(`  Completed handoffs: ${JSON.stringify(handoffCounts)}`);
  console.log(`  Milestone scores: ${JSON.stringify(milestoneScores)}`);

  const now = Date.now();
  const result = {
    lastUpdated: new Date().toISOString(),
    agents: {},
    russell: {},
  };

  // Compute metrics per window
  for (const [windowKey, windowMs] of Object.entries(WINDOWS)) {
    const cutoff = now - windowMs;
    const relevantSessions = sessions.filter(s => s.date.getTime() >= cutoff);

    // Quest scores for this window
    const questScores = computeQuestScores(sessions, windowMs, researchCounts, handoffCounts, milestoneScores);

    for (const agent of AGENTS) {
      if (!result.agents[agent]) result.agents[agent] = {};

      let totalCost = 0;
      let totalDurationMs = 0;
      let totalTokens = 0;
      let sessionCount = 0;

      for (const session of relevantSessions) {
        const agentCost = session.byAgent[agent];
        if (agentCost !== undefined) {
          totalCost += agentCost;
          // Duration proportional to agent's participation
          const participants = Object.keys(session.byAgent).length;
          totalDurationMs += (session.durationS * 1000) / Math.max(participants, 1);
          // Tokens estimated from cost proportion
          const proportion = session.totalCost > 0 ? agentCost / session.totalCost : 0;
          totalTokens += Math.round(session.totalTokens * proportion);
          sessionCount++;
        }
      }

      const durationHrs = totalDurationMs / 3600000;
      const costPerHr = durationHrs > 0 ? totalCost / durationHrs : 0;

      result.agents[agent][windowKey] = {
        costUsd: Math.round(totalCost * 10000) / 10000,
        costPerHr: Math.round(costPerHr * 100) / 100,
        durationMs: Math.round(totalDurationMs),
        tokens: totalTokens,
        sessions: sessionCount,
        questScore: questScores[agent]?.total || 0,
        questBreakdown: questScores[agent] || { output: 0, milestones: 0, efficiency: 0, initiative: 0, total: 0 },
      };
    }

    // Russell metrics
    result.russell[windowKey] = {
      questScore: questScores['russell']?.total || 0,
      questBreakdown: questScores['russell'] || { output: 0, milestones: 0, efficiency: 0, initiative: 0, total: 0 },
    };
  }

  // Ensure output directory exists
  const outputDir = path.dirname(OUTPUT_PATH);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  fs.writeFileSync(OUTPUT_PATH, JSON.stringify(result, null, 2));
  console.log(`  Metrics written to ${OUTPUT_PATH}`);
  console.log('Done.');
}

main();
