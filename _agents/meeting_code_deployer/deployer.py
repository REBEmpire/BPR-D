"""Meeting-Code-Deployer - Main orchestrator for processing meeting transcripts."""

import json
import subprocess
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Any, Optional
import yaml

from .parser import TranscriptParser, ParsedTranscript, ActionItem
from .skill_linker import SkillLinker, SkillLinkResult
from .code_generator import CodeGenerator, GeneratedFile
from .task_creator import TaskCreator, TaskFile


@dataclass
class DeploymentReport:
    """Complete report of a deployment run."""
    meeting_id: str
    transcript_path: str
    timestamp: str
    dry_run: bool
    
    # Extraction results
    action_items_found: int = 0
    decisions_found: int = 0
    code_snippets_found: int = 0
    
    # Skill linking results
    skills_linked: int = 0
    skill_gaps: int = 0
    
    # Task creation results
    tasks_created: List[Dict[str, Any]] = field(default_factory=list)
    
    # File generation results
    files_generated: List[Dict[str, Any]] = field(default_factory=list)
    
    # Errors and warnings
    errors: List[str] = field(default_factory=list)
    warnings: List[str] = field(default_factory=list)
    
    def to_markdown(self) -> str:
        """Generate markdown report."""
        status = "DRY RUN" if self.dry_run else "DEPLOYED"
        
        report = f"""# Meeting-Code-Deployer Report

**Status:** {status}  
**Meeting ID:** {self.meeting_id}  
**Timestamp:** {self.timestamp}  
**Transcript:** `{self.transcript_path}`

---

## Summary

| Metric | Count |
|--------|-------|
| Action Items | {self.action_items_found} |
| Decisions | {self.decisions_found} |
| Code Snippets | {self.code_snippets_found} |
| Skills Linked | {self.skills_linked} |
| Skill Gaps | {self.skill_gaps} |
| Tasks Created | {len(self.tasks_created)} |
| Files Generated | {len(self.files_generated)} |

---

## Tasks Created

"""
        
        if self.tasks_created:
            report += "| Task ID | Title | Owner | Status | Path |\n"
            report += "|---------|-------|-------|--------|------|\n"
            for task in self.tasks_created:
                report += f"| {task.get('task_id', 'N/A')} | {task.get('title', 'N/A')[:30]}... | {task.get('owner', '-')} | {task.get('status', '-')} | `{task.get('path', '')}` |\n"
        else:
            report += "*No tasks created*\n"
        
        report += "\n---\n\n## Files Generated\n\n"
        
        if self.files_generated:
            report += "| Path | Type | Description |\n"
            report += "|------|------|-------------|\n"
            for f in self.files_generated:
                report += f"| `{f.get('path', '')}` | {f.get('type', 'N/A')} | {f.get('description', '')[:40]} |\n"
        else:
            report += "*No files generated*\n"
        
        if self.warnings:
            report += "\n---\n\n## Warnings\n\n"
            for warning in self.warnings:
                report += f"- âš ï¸ {warning}\n"
        
        if self.errors:
            report += "\n---\n\n## Errors\n\n"
            for error in self.errors:
                report += f"- âŒ {error}\n"
        
        report += f"""
---

## Next Steps

1. Review generated tasks in `tasks/` directory
2. Assign owners to unassigned tasks
3. Link any skill gaps to appropriate nodes
4. Commit changes to repository

---

*Generated by Meeting-Code-Deployer v2.0.0 at {self.timestamp}*
"""
        
        return report
    
    def to_json(self) -> str:
        """Generate JSON report."""
        return json.dumps({
            'meeting_id': self.meeting_id,
            'transcript_path': self.transcript_path,
            'timestamp': self.timestamp,
            'dry_run': self.dry_run,
            'metrics': {
                'action_items': self.action_items_found,
                'decisions': self.decisions_found,
                'code_snippets': self.code_snippets_found,
                'skills_linked': self.skills_linked,
                'skill_gaps': self.skill_gaps,
                'tasks_created': len(self.tasks_created),
                'files_generated': len(self.files_generated)
            },
            'tasks': self.tasks_created,
            'files': self.files_generated,
            'errors': self.errors,
            'warnings': self.warnings
        }, indent=2)


class MeetingCodeDeployer:
    """Main orchestrator for the Meeting-Code-Deployer pipeline."""
    
    def __init__(self, config_path: Optional[str] = None, repo_root: Optional[str] = None):
        self.repo_root = Path(repo_root) if repo_root else Path.cwd()
        
        # Load configuration
        if config_path:
            config_file = Path(config_path)
        else:
            config_file = self.repo_root / '_agents' / 'meeting_code_deployer' / 'config.yaml'
        
        if config_file.exists():
            with open(config_file, 'r') as f:
                self.config = yaml.safe_load(f)
        else:
            self.config = self._get_default_config()
        
        # Initialize components
        self.parser = TranscriptParser(self.config)
        self.skill_linker = SkillLinker(self.config, str(self.repo_root))
        self.code_generator = CodeGenerator(self.config, str(self.repo_root))
        self.task_creator = TaskCreator(self.config, str(self.repo_root))
    
    def _get_default_config(self) -> Dict[str, Any]:
        """Return default configuration."""
        return {
            'mcd': {
                'paths': {
                    'skill_web': '_shared/skill-graphs/bprd-core',
                    'tasks_dir': 'tasks',
                    'meetings_dir': 'meetings/logs',
                    'todo_list': 'BPR&D_To_Do_List.md',
                    'counter_file': 'tasks/_counter.yaml'
                },
                'extraction': {
                    'min_confidence': 0.7,
                    'auto_assign': True,
                    'skill_matching': True,
                    'action_patterns': [
                        'will implement', 'will create', 'will update',
                        'will fix', 'will add', 'will review', 'will research',
                        "let's make sure", 'we need to', 'TODO:', 'ACTION:', 'TASK:'
                    ],
                    'decision_patterns': [
                        'we decided', 'agreed to', 'final decision', 'DECISION:', 'approved'
                    ]
                },
                'code_pipeline': {
                    'auto_branch': True,
                    'branch_prefix': 'task/',
                    'require_pr': True,
                    'auto_deploy': False
                },
                'agents': [
                    {'name': 'grok', 'skills': ['strategic-direction', 'meeting-engine']},
                    {'name': 'claude', 'skills': ['code-review', 'api-development']},
                    {'name': 'abacus', 'skills': ['system-architecture', 'automation']},
                    {'name': 'gemini', 'skills': ['research', 'analysis']},
                    {'name': 'perplexity', 'skills': ['verification', 'fact-checking']},
                    {'name': 'russell', 'skills': ['operations', 'telegram-alerts']}
                ]
            }
        }
    
    def process(self, transcript_path: str, 
                dry_run: bool = False,
                auto_commit: bool = False,
                create_pr: bool = False,
                verbose: bool = True) -> DeploymentReport:
        """Process a meeting transcript through the full pipeline."""
        
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        
        # Initialize report
        report = DeploymentReport(
            meeting_id="",
            transcript_path=transcript_path,
            timestamp=timestamp,
            dry_run=dry_run
        )
        
        try:
            # Stage 1: Parse transcript
            if verbose:
                print(f"ðŸ“„ Parsing transcript: {transcript_path}")
            
            parsed = self.parser.parse(transcript_path)
            report.meeting_id = parsed.metadata.meeting_id
            report.action_items_found = len(parsed.action_items)
            report.decisions_found = len(parsed.decisions)
            report.code_snippets_found = len(parsed.code_snippets)
            
            if verbose:
                print(f"   Found: {report.action_items_found} actions, {report.decisions_found} decisions, {report.code_snippets_found} code snippets")
            
            # Stage 2: Link to skill-web
            if verbose:
                print("ðŸ”— Linking to skill-web nodes...")
            
            skill_links: Dict[int, SkillLinkResult] = {}
            for action in parsed.action_items:
                link_result = self.skill_linker.link_action_item(
                    action.raw_text, action.keywords
                )
                skill_links[action.line_number] = link_result
                
                if link_result.primary_skill:
                    report.skills_linked += 1
                if link_result.has_skill_gap:
                    report.skill_gaps += 1
            
            if verbose:
                print(f"   Linked: {report.skills_linked}, Gaps: {report.skill_gaps}")
            
            # Stage 3: Create tasks
            if verbose:
                print("ðŸ“ Creating task files...")
            
            tasks: List[TaskFile] = []
            task_ids = self.task_creator.peek_next_task_ids(len(parsed.action_items))
            
            for i, action in enumerate(parsed.action_items):
                if action.confidence >= self.config.get('mcd', {}).get('extraction', {}).get('min_confidence', 0.7):
                    task_id = task_ids[i] if i < len(task_ids) else None
                    skill_link = skill_links.get(action.line_number)
                    
                    task = self.task_creator.create_task_from_action(
                        action=action,
                        skill_link=skill_link,
                        meeting_source=transcript_path,
                        task_id=task_id,
                        dry_run=dry_run
                    )
                    tasks.append(task)
                else:
                    report.warnings.append(
                        f"Action at line {action.line_number} skipped (confidence {action.confidence:.0%} < threshold)"
                    )
            
            # Write task files
            if tasks:
                write_results = self.task_creator.write_tasks(tasks, dry_run=dry_run)
                
                for task in tasks:
                    report.tasks_created.append({
                        'task_id': task.task_id,
                        'title': task.title,
                        'path': task.path,
                        'owner': task.owner,
                        'status': task.status,
                        'skill': task.skill_web_node
                    })
                
                if write_results['errors']:
                    for err in write_results['errors']:
                        report.errors.append(f"Task {err['task_id']}: {err['error']}")
            
            if verbose:
                print(f"   Created: {len(tasks)} tasks")
            
            # Stage 4: Generate documentation and code files
            if verbose:
                print("ðŸ“ Generating files...")
            
            generated_files: List[GeneratedFile] = []
            
            # Meeting summary
            summary = self.code_generator.generate_documentation(
                action_items=parsed.action_items,
                decisions=parsed.decisions,
                skill_links=skill_links,
                meeting_id=parsed.metadata.meeting_id,
                meeting_date=parsed.metadata.date
            )
            generated_files.append(summary)
            
            # Skill gap report if needed
            if report.skill_gaps > 0:
                gap_report = self.code_generator.generate_skill_gap_report(
                    action_items=parsed.action_items,
                    skill_links=skill_links,
                    meeting_id=parsed.metadata.meeting_id
                )
                if gap_report:
                    generated_files.append(gap_report)
            
            # Code snippets
            if parsed.code_snippets:
                code_files = self.code_generator.generate_from_code_snippets(
                    parsed.code_snippets, parsed.metadata.meeting_id
                )
                generated_files.extend(code_files)
            
            # Write generated files
            for gen_file in generated_files:
                file_path = self.repo_root / gen_file.path
                
                if not dry_run:
                    file_path.parent.mkdir(parents=True, exist_ok=True)
                    file_path.write_text(gen_file.content, encoding='utf-8')
                
                report.files_generated.append({
                    'path': gen_file.path,
                    'type': gen_file.file_type,
                    'description': gen_file.description
                })
            
            if verbose:
                print(f"   Generated: {len(generated_files)} files")
            
            # Stage 5: Update To-Do List
            if verbose:
                print("ðŸ“‹ Updating To-Do List...")
            
            todo_result = self.task_creator.update_todo_list(tasks, dry_run=dry_run)
            if verbose:
                print(f"   {todo_result}")
            
            # Stage 6: Git operations (if requested)
            if not dry_run and (auto_commit or create_pr):
                if verbose:
                    print("ðŸ”§ Git operations...")
                
                self._handle_git_operations(
                    report=report,
                    auto_commit=auto_commit,
                    create_pr=create_pr,
                    verbose=verbose
                )
            
            if verbose:
                print(f"âœ… {'Dry run' if dry_run else 'Deployment'} complete!")
            
        except FileNotFoundError as e:
            report.errors.append(f"File not found: {e}")
        except Exception as e:
            report.errors.append(f"Unexpected error: {str(e)}")
        
        return report
    
    def _handle_git_operations(self, report: DeploymentReport,
                               auto_commit: bool, create_pr: bool,
                               verbose: bool) -> None:
        """Handle git commit and PR creation."""
        
        if auto_commit:
            # Stage all new files
            all_paths = [t['path'] for t in report.tasks_created]
            all_paths.extend([f['path'] for f in report.files_generated])
            
            try:
                for path in all_paths:
                    subprocess.run(
                        ['git', 'add', path],
                        cwd=str(self.repo_root),
                        check=True,
                        capture_output=True
                    )
                
                # Commit
                commit_msg = f"[MCD] Process meeting: {report.meeting_id}\n\n"
                commit_msg += f"- Created {len(report.tasks_created)} tasks\n"
                commit_msg += f"- Generated {len(report.files_generated)} files\n"
                commit_msg += f"\nTimestamp: {report.timestamp}"
                
                subprocess.run(
                    ['git', 'commit', '-m', commit_msg],
                    cwd=str(self.repo_root),
                    check=True,
                    capture_output=True
                )
                
                if verbose:
                    print("   Committed changes")
                    
            except subprocess.CalledProcessError as e:
                report.errors.append(f"Git commit failed: {e.stderr.decode() if e.stderr else str(e)}")
        
        if create_pr:
            # This would integrate with GitHub API
            report.warnings.append("PR creation requires GitHub integration (not implemented in standalone mode)")
    
    def generate_report(self, report: DeploymentReport, 
                        format: str = "markdown") -> str:
        """Generate a formatted report."""
        if format == "json":
            return report.to_json()
        return report.to_markdown()
    
    def save_report(self, report: DeploymentReport, 
                    output_path: Optional[str] = None,
                    format: str = "markdown") -> str:
        """Save report to file."""
        if output_path is None:
            ext = ".json" if format == "json" else ".md"
            output_path = f"meetings/reports/{report.meeting_id}-deployment-report{ext}"
        
        output_file = self.repo_root / output_path
        output_file.parent.mkdir(parents=True, exist_ok=True)
        
        content = self.generate_report(report, format)
        output_file.write_text(content, encoding='utf-8')
        
        return str(output_file)
